<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/"><channel><title>Ubuntu on AI 避难所</title><link>https://jackypanster.github.io/ai-stream/tags/ubuntu/</link><description>Recent content in Ubuntu on AI 避难所</description><generator>Hugo -- 0.148.1</generator><language>en-us</language><lastBuildDate>Wed, 16 Jul 2025 18:14:40 +0800</lastBuildDate><atom:link href="https://jackypanster.github.io/ai-stream/tags/ubuntu/index.xml" rel="self" type="application/rss+xml"/><item><title>Ubuntu 24.04 终极性能调优指南：从系统臃肿到内核定制</title><link>https://jackypanster.github.io/ai-stream/posts/ubuntu-24-04-performance-tuning-guide/</link><pubDate>Wed, 16 Jul 2025 18:14:40 +0800</pubDate><guid>https://jackypanster.github.io/ai-stream/posts/ubuntu-24-04-performance-tuning-guide/</guid><description>一份面向开发者的深度指南，记录了如何通过移除 Snap、更换 XanMod 内核、禁用 CPU 安全缓解等一系列硬核操作，将一台标准 Ubuntu 24.04 工作站打造成极致性能的开发机器。</description><content:encoded><![CDATA[<h2 id="第一章大扫除--根除-snap-生态">第一章：大扫除 —— 根除 Snap 生态</h2>
<p><strong>背景分析</strong>：Snap 是 Canonical 推出的通用软件包格式，旨在简化跨发行版部署。其沙箱机制带来了安全优势，但也引入了显著的性能开销：首次启动缓慢、后台服务（<code>snapd</code>）持续占用资源、以及磁盘空间的大量消耗（每个应用都是一个独立的 loop device）。对于开发者来说，这些代价远超其带来的便利。</p>
<p><strong>行动方案</strong>：我们的第一步，就是彻底、干净地移除整个 Snap 生态系统。</p>
<ol>
<li>
<p><strong>识别并卸载所有已安装的 Snap 包</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 列出所有已安装的 snap 包</span>
</span></span><span style="display:flex;"><span>snap list
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 逐一卸载，从 Firefox 开始</span>
</span></span><span style="display:flex;"><span>sudo snap remove --purge firefox
</span></span><span style="display:flex;"><span>sudo snap remove --purge snap-store
</span></span><span style="display:flex;"><span><span style="color:#75715e"># ...卸载其他所有 snap 包...</span>
</span></span></code></pre></div></li>
<li>
<p><strong>停止并禁用 <code>snapd</code> 服务</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo systemctl disable --now snapd.service snapd.socket snapd.seeded.service
</span></span></code></pre></div></li>
<li>
<p><strong>彻底清除 <code>snapd</code> 及其残留文件</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt autoremove --purge snapd -y
</span></span><span style="display:flex;"><span>rm -rf ~/snap
</span></span><span style="display:flex;"><span>sudo rm -rf /var/cache/snapd/
</span></span></code></pre></div></li>
</ol>
<p><strong>关键问题：Firefox 的替代方案</strong></p>
<p>移除 Snap 版 Firefox 后，我们需要一个原生的替代品。最佳选择是 Mozilla 官方提供的 PPA（Personal Package Archive）。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 添加 Mozilla 官方 PPA</span>
</span></span><span style="display:flex;"><span>sudo add-apt-repository ppa:mozillateam/ppa
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 配置 PPA 优先级，确保系统优先选择 PPA 版本而非 Snap 版本</span>
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Package: *
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Pin: release o=LP-PPA-mozillateam
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">Pin-Priority: 1001
</span></span></span><span style="display:flex;"><span><span style="color:#e6db74">&#39;</span> | sudo tee /etc/apt/preferences.d/mozilla-firefox
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 安装原生 .deb 版 Firefox</span>
</span></span><span style="display:flex;"><span>sudo apt update <span style="color:#f92672">&amp;&amp;</span> sudo apt install firefox -y
</span></span></code></pre></div><p>至此，我们完成了第一项重大优化。系统变得更加轻盈，后台噪音显著减少。</p>
<hr>
<h2 id="第二章心脏移植--换装-xanmod-内核">第二章：心脏移植 —— 换装 XanMod 内核</h2>
<p><strong>背景分析</strong>：Linux 内核是操作系统的核心，负责管理 CPU、内存和硬件。Ubuntu 的通用内核（Generic Kernel）为了稳定性和兼容性，在调度器等方面做了很多保守的权衡。而 <strong>XanMod 内核</strong> 是一个社区驱动的项目，专为桌面、多媒体和游戏等高响应性场景优化。它采用了更先进的进程调度器（如 Task Type Scheduler）、更低的延迟配置和最新的内核补丁，能显著提升系统的交互流畅度和吞吐量。</p>
<p><strong>行动方案</strong>：为我们的系统更换一颗更强劲的“心脏”。</p>
<ol>
<li>
<p><strong>添加 XanMod 的软件源</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>wget -qO - https://dl.xanmod.org/archive.key | sudo gpg --dearmor -o /usr/share/keyrings/xanmod-archive-keyring.gpg
</span></span><span style="display:flex;"><span>echo <span style="color:#e6db74">&#39;deb [signed-by=/usr/share/keyrings/xanmod-archive-keyring.gpg] http://deb.xanmod.org releases main&#39;</span> | sudo tee /etc/apt/sources.list.d/xanmod-release.list
</span></span></code></pre></div></li>
<li>
<p><strong>安装针对现代 CPU 优化的版本</strong>：
XanMod 提供多个版本。对于现代 AMD 和 Intel CPU（2015年后），<code>x64v3</code> 版本是最佳选择，因为它利用了 AVX/AVX2 等新指令集。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span>sudo apt update
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 安装 x64v3 版本的 LTS (长期支持) 内核</span>
</span></span><span style="display:flex;"><span>sudo apt install linux-xanmod-lts-x64v3 -y
</span></span></code></pre></div></li>
<li>
<p><strong>重启与验证</strong>：
安装后，<strong>必须重启</strong>系统以加载新内核。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 重启电脑</span>
</span></span><span style="display:flex;"><span>sudo reboot
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 重启后，验证内核版本</span>
</span></span><span style="display:flex;"><span>uname -r
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 预期输出应包含 &#39;xanmod&#39;</span>
</span></span></code></pre></div></li>
</ol>
<p>完成这一步后，您会直观地感觉到系统响应速度的提升，尤其是在高负载下的多任务处理场景。</p>
<hr>
<h2 id="第三章解除封印--禁用-cpu-安全缓解">第三章：解除封印 —— 禁用 CPU 安全缓解</h2>
<p><strong>背景分析</strong>：这是本次优化中最硬核、也最具争议的一步。自 Spectre 和 Meltdown 漏洞被发现以来，所有现代操作系统都加入了软件层面的“缓解措施”（Mitigations）来防止恶意攻击。然而，这些安全补丁是有性能代价的，它们会给 CPU 带来 5% 到 30% 不等的性能损失。</p>
<p>对于一个物理隔离、不运行不受信任代码、且数据非高度敏感的开发工作站来说，我们可以做出一个权衡：<strong>用可接受的安全风险，换取可观的原始计算性能</strong>。这对于编译、科学计算和 AI 推理等 CPU 密集型任务，收益巨大。</p>
<p><strong>行动方案</strong>：通过修改 GRUB 引导参数，指示内核在启动时禁用这些缓解措施。为了确保操作的安全性和可逆性，我们创建了一个一键式开关脚本。</p>
<ol>
<li>
<p><strong>创建 <code>toggle_cpu_mitigations.sh</code> 脚本</strong>：
这个脚本的核心是通过修改 <code>/etc/default/grub</code> 文件中的 <code>GRUB_CMDLINE_LINUX_DEFAULT</code> 行，来添加或移除 <code>mitigations=off</code> 参数。</p>
<p><em>完整脚本内容请参考项目 Git 仓库。</em></p>
</li>
<li>
<p><strong>执行脚本以禁用缓解措施</strong>：</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 赋予脚本执行权限</span>
</span></span><span style="display:flex;"><span>chmod +x toggle_cpu_mitigations.sh
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 运行脚本以关闭缓解措施</span>
</span></span><span style="display:flex;"><span>sudo ./toggle_cpu_mitigations.sh on
</span></span></code></pre></div><p>该脚本会自动备份原始配置，然后应用更改并更新 GRUB。</p>
</li>
<li>
<p><strong>重启与验证</strong>：
同样，<strong>必须重启</strong>才能使更改生效。</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-bash" data-lang="bash"><span style="display:flex;"><span><span style="color:#75715e"># 重启电脑</span>
</span></span><span style="display:flex;"><span>sudo reboot
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#75715e"># 重启后，检查漏洞状态</span>
</span></span><span style="display:flex;"><span>cat /sys/devices/system/cpu/vulnerabilities/*
</span></span></code></pre></div><p>如果看到多个漏洞的状态从 <code>Mitigation</code> 变为 <code>Vulnerable</code>，这<strong>不是警报</strong>，而是<strong>成功的标志</strong>。它证明了系统的“封印”已被解除，CPU 正以其最原始的性能运行。</p>
</li>
</ol>
]]></content:encoded></item><item><title>AppArmor配置残留问题排查与彻底解决：从报错到系统净化的完整实践</title><link>https://jackypanster.github.io/ai-stream/posts/apparmor-troubleshooting/</link><pubDate>Mon, 09 Jun 2025 11:19:33 +0800</pubDate><guid>https://jackypanster.github.io/ai-stream/posts/apparmor-troubleshooting/</guid><description>深入解析Ubuntu系统中AppArmor服务的SSSD配置残留问题，从原理分析到彻底解决的完整技术指南，适合系统运维工程师参考。</description><content:encoded><![CDATA[<h2 id="一问题背景警告频发的sssd配置残留">一、问题背景：警告频发的SSSD配置残留</h2>
<p>在Ubuntu服务器维护过程中，长期被AppArmor服务的SSSD相关警告困扰。具体表现为：</p>
<ul>
<li>每次重启AppArmor服务时，日志频繁提示<code>Warning: found usr.sbin.sssd in /etc/apparmor.d/force-complain</code></li>
<li><code>apparmor_status</code>持续显示<code>/usr/sbin/sssd</code>配置存在，但实际已卸载SSSD服务</li>
<li>系统日志中伴随<code>Caching disabled for: 'usr.sbin.sssd' due to force complain</code>警告，影响服务稳定性评估</li>
</ul>
<h2 id="二技术分析深入apparmor的配置逻辑">二、技术分析：深入AppArmor的配置逻辑</h2>
<h3 id="1-apparmor的配置加载机制">1. AppArmor的配置加载机制</h3>
<ul>
<li><strong>主配置目录</strong>：<code>/etc/apparmor.d/</code> 存放系统级配置</li>
<li><strong>本地覆盖目录</strong>：<code>/etc/apparmor.d.local/</code> 优先级高于主目录，用于本地自定义策略</li>
<li><strong>运行时缓存</strong>：AppArmor会将配置加载到内核并缓存，即使删除文件也可能残留运行时状态</li>
</ul>
<h3 id="2-sssd服务的特殊性">2. SSSD服务的特殊性</h3>
<ul>
<li>该服务默认随Ubuntu部分版本安装，提供LDAP/NIS等认证功能</li>
<li>卸载时默认保留配置文件（<code>/etc/apparmor.d/usr.sbin.sssd</code>），导致AppArmor持续尝试加载已删除服务的策略</li>
</ul>
<h3 id="3-关键报错溯源-核心错误日志">3. 关键报错溯源# 核心错误日志</h3>
<p>apparmor.systemd[12435]: /lib/apparmor/apparmor.systemd: 148: [: Illegal number: yes
apparmor.systemd[12546]: Warning: found usr.sbin.sssd in /etc/apparmor.d/force-complain, forcing complain mode- 语法错误源于<code>rc.apparmor.functions</code>中数值比较符误用（<code>-eq</code>未转义字符串）</p>
<ul>
<li>警告本质是残留配置与运行时状态的冲突</li>
</ul>
<h2 id="三分步解决方案从手动清理到内核级重置">三、分步解决方案：从手动清理到内核级重置</h2>
<h3 id="1-语法修复修正apparmor函数库-定位关键函数">1. 语法修复：修正AppArmor函数库# 定位关键函数</h3>
<p>sudo nano /lib/apparmor/rc.apparmor.functions</p>
<ul>
<li>修改check_userns函数中的比较符
原代码：
if [ &ldquo;$userns_restricted&rdquo; -eq 1 ]; then
修正后：
if [ &ldquo;$userns_restricted&rdquo; = &ldquo;1&rdquo; ]; then</li>
</ul>
<h3 id="2-服务卸载与配置清理-彻底卸载sssd">2. 服务卸载与配置清理# 彻底卸载SSSD</h3>
<p>sudo apt remove &ndash;purge sssd sssd-tools</p>
<ul>
<li>
<p>删除主目录配置
sudo rm -f /etc/apparmor.d/usr.sbin.sssd</p>
</li>
<li>
<p>发现并删除local目录残留
sudo find /etc/apparmor.d/ -name &ldquo;<em>sssd</em>&rdquo;</p>
</li>
<li>
<p>输出：/etc/apparmor.d.local/usr.sbin.sssd
sudo rm -f /etc/apparmor.d.local/usr.sbin.sssd</p>
</li>
</ul>
<h3 id="3-运行时状态重置-停止apparmor服务">3. 运行时状态重置# 停止AppArmor服务</h3>
<p>sudo systemctl stop apparmor</p>
<ul>
<li>
<p>（注意：Ubuntu内核内置AppArmor，无需modprobe卸载模块）</p>
</li>
<li>
<p>强制重新加载配置并清除缓存
sudo apparmor_parser -r /etc/apparmor.d/
sudo systemctl restart apparmor</p>
</li>
</ul>
<h3 id="4-终极验证-检查配置是否彻底移除">4. 终极验证# 检查配置是否彻底移除</h3>
<p>sudo apparmor_status | grep sssd</p>
<ul>
<li>
<p>预期输出：无任何结果</p>
</li>
<li>
<p>确认服务状态
sudo systemctl status apparmor</p>
</li>
<li>
<p>理想状态：active (exited) 且无警告日志</p>
</li>
</ul>
<h2 id="四技术总结与最佳实践">四、技术总结与最佳实践</h2>
<h3 id="1-apparmor运维关键点">1. AppArmor运维关键点</h3>
<ul>
<li><strong>配置优先级</strong>：<code>local/</code>目录配置会覆盖主目录，卸载服务后需特别检查</li>
<li><strong>缓存机制</strong>：修改配置后需通过<code>-r</code>参数或重启服务清除内核缓存</li>
<li><strong>内置模块特性</strong>：Ubuntu官方内核默认内置AppArmor，避免使用<code>modprobe</code>操作模块</li>
</ul>
<h3 id="2-服务卸载规范-标准卸载流程">2. 服务卸载规范# 标准卸载流程</h3>
<ol>
<li>停止服务：sudo systemctl stop <!-- raw HTML omitted --></li>
<li>卸载软件包：sudo apt remove &ndash;purge <!-- raw HTML omitted --></li>
<li>搜索残留配置：sudo find /etc/ -name &ldquo;<em><!-- raw HTML omitted --></em>&rdquo;</li>
<li>清理日志与缓存：sudo rm -rf /var/log/<!-- raw HTML omitted --> /var/cache/<!-- raw HTML omitted --></li>
</ol>
<h3 id="3-常见问题预判">3. 常见问题预判</h3>
<ul>
<li><strong>Q：为何删除文件后警告仍存在？</strong><br>
A：AppArmor内核缓存未更新，需通过<code>systemctl restart apparmor</code>强制刷新</li>
<li><strong>Q：能否直接禁用AppArmor？</strong><br>
A：不建议。作为系统安全核心组件，禁用会导致权限控制失效，应优先清理配置而非关闭服务</li>
</ul>
<h2 id="五结语">五、结语</h2>
<p>本次排障深入操作系统安全模块的底层逻辑，通过「语法修复→服务卸载→配置清理→状态重置」的完整链路，彻底解决了长期存在的配置残留问题。实践表明，处理系统级安全组件时，需兼顾文件系统清理与内核运行时状态管理，同时重视配置目录的优先级规则。希望本文能为运维工程师在处理类似问题时提供可复用的技术范式，在保证系统安全性的前提下实现高效维护。</p>
<p><strong>参考资料</strong></p>
<ul>
<li><a href="https://gitlab.com/apparmor/apparmor/wikis/home">AppArmor官方文档</a></li>
<li><a href="https://ubuntu.com/server/docs/service-management">Ubuntu服务管理最佳实践</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/security/apparmor.html">Linux内核模块与AppArmor集成机制</a></li>
</ul>
]]></content:encoded></item></channel></rss>